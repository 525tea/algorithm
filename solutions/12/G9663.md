# #9663 N-Queen 해설

## 1. 문제

N * N의 체스판에 N개의 퀸을 서로 공격할 수 없게 놓는 방법의 수를 구하라

퀸의 이동 룰은 상, 하, 좌, 우, 대각선이다

<br>

## 2. 설계

- 한 행에 퀸을 1개씩 반드시 배치
- isUsed 배열을 사용

상, 하(같은 열), y = x 대각선, y = -x 대각선을 각각 isUsed 배열을 사용해 방문 체크를 구현한다

        (0, 0) (0, 1) (0, 2)
        (1, 0) (1, 1) (1, 2)
        (2, 0) (2, 1) (2, 2)

행렬의 좌표 체계를 보면 우상향(좌표 평면상 y = x) 대각선은 y = - x + a 꼴,
우하향(좌표 평면상 y = -x) 대각선은 y = x + a꼴임을 알 수 있다

좌, 우(같은 행) 는 한 행헤 하나씩만 배치하는 룰로 대치한다 

- isUsed1 : 열(y)을 지나는 값
  - (x, y)에 퀸이 있으면 -> isUsed1[y] = true 처리
- isUsed2 : y = x 대각선을 지나는 값
  - (x, y)에 퀸이 있으면 -> isUsed2[x+y] = true 처리
- isUsed3 : y = -x 대각선을 지나는 값 
  - (x, y)에 퀸이 있으면 -> isUsed3[x-y+n-1] = true 처리
  - +(n-1)은 인덱스가 0부터 시작하게 하기 위한 장치, 인덱스의 음수 방지

### 함수 정의

- func(cur) -> cur행(cur = 0 ~ N-1)에 퀸을 배치하는 함수
  - fori 루프 
    - i에 배치 가능
    <br> -> (cur, i)에 퀸 배치,
    <br> isUsed1[i], isUsed2[cur + i], isUsed3[cur - i + n - 1] true 처리
    - **재귀 호출** func(cur + 1)
    - 재귀 탈출할 때 isUsed **원복**

<br>

## 3. 구현

```java
import java.io.*;
import java.util.*;

public class G9663V3 {
    static int N;
    static boolean[] isUsed1 = new boolean[40]; // 같은 열 체크
    static boolean[] isUsed2 = new boolean[40]; // 오른쪽 위 대각선 (r+c)
    static boolean[] isUsed3 = new boolean[40]; // 왼쪽 위 대각선 (r-c+n-1)
    static int count = 0;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        func(0);
        System.out.println(count);
    }

    static void func(int cur) {
        // base condition: 모든 행에 퀸을 배치한 경우
        if (cur == N) {
            count++;
            return;
        }

        for (int i = 0; i < N; i++) {
            // 같은 열, 대각선에 이미 퀸이 있으면 건너뛰기
            if (isUsed1[i] || isUsed2[i + cur] || isUsed3[cur - i + N - 1]) continue;

            // 현재 위치에 퀸 배치
            isUsed1[i] = true;
            isUsed2[i + cur] = true;
            isUsed3[cur - i + N - 1] = true;

            func(cur + 1); // 다음 행으로 이동

            // 백트래킹 (원상복구)
            isUsed1[i] = false;
            isUsed2[i + cur] = false;
            isUsed3[cur - i + N - 1] = false;
        }
    }
}
```

<br>

## 4. 알고리즘 선택 팁 

백트래킹에서 가지치기가 되면 시간복잡도를 정확하게 가늠하기 어려움

-> N이 아주 작다면 직접 구현한 뒤 시간 초과가 나는지 안 나는지를 보면 된다
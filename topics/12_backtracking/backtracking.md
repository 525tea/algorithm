### ✏️ 백트래킹 개념
- [N-Queen 해설](/solutions/s12/G9663.md)
- [next permutation](/topics/12_backtracking/next_permutation.md)

### [📁 백트래킹 문제 리스트](/topics/12_backtracking/12_backtracking.md)

# 백트래킹 (Backtracking)

>진행하다가 조건을 만족하지 않으면 후진(이전 단계로 한 단계씩 롤백)하며 다른 선택을 시도하는 탐색 방식

- 모든 경우의 수 중에서 가능성 있는 경우의 수만 찾아보는 방법
    - 브루트포스는 그냥 모든 경우의 수를 다 찾아보는 것
- 해당 범위 내에서 조건을 추가, 값의 유망성을 판단 ⇒ 노드의 유망성을 판단
- 노드가 유망하지 않다 판단되면 부모 노드로 돌아가 다른 자식 노드를 찾음

```java
void backtrack(현재_상태) {
    if (정답을_찾았거나_끝까지_왔으면) {
        정답_처리;
        return;
    }

    for (가능한_선택들) {
        선택하기;
        backtrack(다음_상태);
        선택_취소하기; // 되돌아가기
    }
}
```

    * 백트래킹은 DFS(깊이 우선 탐색) 구조 위에서,
    * 각 depth(즉, 현재 상태)에서 하나의 선택을 했다가,
    * 밑으로 내려가서 모든 경우를 다 탐색한 다음
    * 되돌아와서 그 선택을 취소(원복)하고 다른 선택지를 시도하는 알고리즘

<br>

    백트래킹은 “DFS(한 깊이로 바닥까지 내려가기) + 가지치기 + 필요 시 원복”
    원복이 꼭 필요한 건 아니며, 상태가 다른 경로에 영향을 줄 수 있으면 반드시 필요
    다른 구현 방식(비트마스크, 순열 라이브러리, BFS+백트래킹 등)은 문제에서 만나면 그때 배워도 충분

<br>

## 핵심
1. **탐색 대상을 깊이(depth)로 나누고 순서대로 탐색**
    - 보통 dfs(depth) 형태로 구현
    - 각 depth에서 가능한 모든 경우를 시도
2. **유망성(pruning) 검사**
    - 그 경로가 답이 될 가능성이 없으면 더 내려가지 않고 중단
    - 예: N-Queen에서 공격 가능하면 내려가지 않음
3. **원복**
    - 현재 경로에서 어떤 값을 선택했는데 실패한 경우, 다음 경우를 시도하기 위해 이전 상태로 돌려놓는 것
    - 전역 상태(공유 상태)이고 다음 검사에도 영향을 미칠 때 필요
    - 스도쿠, 연산자 끼워넣기, 조합/순열 생성 등에서 필수
    - N-Queen처럼 덮어쓰기 구조면 안 해도 되는 경우도 있음
    
    | 상황                              | 원복        |                                                          | 문제                          |
    |---------------------------------|-----------|----------------------------------------------------------|-----------------------------|
    | 다음 시도를 위해 현재 상태를 되돌려야 하는 경우     | ✅ 필요        | 현재 선택이 전역/공유 상태에 기록되어 있고, 다른 경우를 시도할 때 영향을 주면 안 됨        | 스도쿠(#2580), 연산자 끼워넣기(#14888) |
    | 다음 시도가 이전 상태를 덮어쓰는 경우        | ❌ 불필요       | 다음 경우를 시도할 때 이전 값이 자동으로 덮어씌워져서 원래 상태 복구가 필요 없음           | N-Queen(#9663)              |
    | 상태를 복사해서 사용                     | ❌ 불필요       | 매 단계마다 새로운 상태 복사본을 만들어 사용하므로 원래 상태에 영향 없음                |                             |
    | 답이 하나만 필요한 조기 종료의 경우            | 경우에 따라 다름 | 정답 찾자마자 탐색 종료하면 원복이 필요 없을 수도 있음, 하지만 구조에 따라 원복 필수일 때도 있음 | 스도쿠(#2580)                  |

4. 종료 조건
    - depth == 목표 깊이 -> 정답 처리 후 return
    - 경우에 따라 조기 종료 플래그(Solved)로 멈추기도 함

<br>

## 패턴

### 1. visited : 상태 기록
- **선택 여부 기록**
- 현재 이 원소가 뽑혔는지(true) 안 뽑혔는지(false)를 저장
- 결과 계산에서 “같은 팀” 또는 “다른 팀” 구분할 때 필요
- 활용 예시 - `순열`

### 2. start : 오름차순 강제, 탐색 경로를 제어
- **중복 제거**용
- 재귀 호출할 때 다음 for문 시작 인덱스를 start로 제한 → {1,3}과 {3,1} 같은 중복 조합 제거
- 예: dfs(depth+1, i+1) 형태

| 상황                        | `start` | `visited` |
|---------------------------|---|---|
| 순열                        | ❌| ✅|
| 중복 순열                     | ❌| ❌|
| 조합                        | ✅| |
| 조합 - 단순 조합 결과만 필요         | ✅| ❌|
| 조합 - 뽑힌/안 뽑힌 원소 둘 다 활용 필요 | ✅| ✅|
| 중복 조합                     | ✅| ❌|

- 활용 예시 - `조합`
- - 단순 조합(출력만 하는 경우): **start만 써도 됨**

    → 뽑힌 원소를 따로 저장해서 출력하면 됨

- **#14889**처럼 뽑힌 팀과 안 뽑힌 팀을 동시에 계산해야 하는 경우: **둘 다 필요**

  → start로 중복 방지, visited로 팀 구분

### 3. 방법 - DFS 깊이 우선 탐색
- 백트래킹의 방법론 중 하나
- **`depth`** 변수가 필요
    - **재귀**가 한 레벨 깊어질 때마다 `dfs(변수들.., **depth + 1**)`
        - `depth++` ❌!!  depth + 1은 재귀를 빠져나오면 값이 복구됨, `depth++`은 복구 안됨
    - `depth == **탐색 범위**` 가 되면 결과를 출력
- 중복 허용 x 조건 ⇒ 방문 여부 기록하는 **`boolean 배열`**
    - 이미 방문한 노드(값)이라면 다음 노드를 탐색하도록 하기 위한 판단지표
- 그 외 풀이에 필요한 변수들


### DFS 설계 방법

- **depth를 무엇으로 잡을 것인지**
    - **탐색이 필요한 대상의 레벨을(범위 증가?) 나누는 방법을 찾아 depth를 지정**
    - depth가 최대깊이에 도달 → `종료 조건`으로 쓰도록 구현
- 조건을 분석해서 dfs에 뭘 `인자`로 넣을건지 설계
- dfs(int depth) 함수로 깊이가 깊어지는 백트래킹 구현
    - depth == 총 깊이로 탐색이 다 끝났는지 검증
    - dfs(depth + 1)로 재귀 진입점 만들어주기
    - 백트래킹으로 전으로 돌아올 때를 대비한 false 처리

```java
void dfs(int node) {
    visited[node] = true; // 방문한 노드는 true 표시

    for (int next : graph[node]) {
        if (!visited[next]) { // 방문한 노드가 아니라면
            dfs(next); // 다음 노드로 이동
        }
    }
}
```

<br>

## 기본 템플릿

```java
void backtrack(현재_상태) {
    if (정답을_찾았거나_끝까지_왔으면) {
        정답_처리;
        return;
    }

    for (가능한_선택들) {
		    if (isValid(...)) {
		        상태 설정
		        backtrack(다음_상태); // 재귀 호출
		        상태 원복 ← 이게 핵심! // 되돌아가기
		    }
		}
}	
```

<br>

## 유형

### 1. 순열, N과 M(1)

**설계**

- arr[] : 현재 단계(수열의 k번째 요소를 선택하는 단계)에서 선택한 숫자들을 저장한 수열
- isUsed[i] : i가 선택되었는지의 여부
- func(k) : arr[]에 k개의 수를 채운 상태에서 arr[k] (다음)를 채우는 함수
  - func(n) n+1 번째 수까기 채운 후 -> func(n+1) 호출 -> ...
- if (k == M) : 모든 위치를 다 채웠으면 출력
- isUsed[i] = false : 재귀 종료 후 상태 복원(백트래킹)
  - arr[]는 어차피 "덮어쓰기"로 값이 바뀌고, 적합성 판단(방문 체크)에 쓰이는 것도 아니니 굳이 원복하지 않는다


arr[] = {1, 2, 3, 4, ..., N}

N = 4, M = 3 (1부터 4까지의 수 중 3개를 선택하는 수열),

지금까지 2, 3 2개를 뽑았다면

isUsed[] = {false, true, true, false}

```java
import java.io.*;
import java.util.*;

public class S15649 {
    static int N, M;
    static int[] arr; // 현재 단계에서 선택한 숫자의 배열
    static boolean[] isUsed; // 특정 수가 쓰였는지의 여부
    static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        arr = new int[M]; // arr[0], ... , arr[M-1] 
        isUsed = new boolean[N + 1]; // i가 이미 선택되었는지의 여부. 1-based(0은 안쓰고 버림)

        func(0); // arr[]은 0-indexed
        System.out.print(sb);
    }

    // k번째 위치를 채우는 함수
    static void func(int k) {
        // base condition: M개를 모두 골랐을 때 출력
        if (k == M) {
            for (int i = 0; i < M; i++) {
                sb.append(arr[i]).append(' ');
            }
            sb.append('\n');
            return;
        }

        for (int i = 1; i <= N; i++) {
            if (!isUsed[i]) {
                arr[k] = i;
                isUsed[i] = true;
                func(k + 1);
                isUsed[i] = false; // 재귀 종료 후 백트래킹 (상태 복원)
            }
        }
    }
}
```
<br>

### 2. N-Queen
[N-Queen 해설](/solutions/s12/G9663.md)

핵심만 말하자면

isUsed로 방문 체크를 간소화하는 것이다

<br>

### 3. 부분 수열의 합

원소가 n개인 집합의 부분집합의 개수는 $2^n$

여기서 원소가 아무것도 없는 공집합을 제외하면 $2^n - 1$

공집합을 제외한 모든 부분집합에 대해 합이 S인지 검증

<br>

### 4. Next_permutation
[참고한 블로그 링크1](https://devje8.tistory.com/17)
[참고한 블로그 링크2](https://sskl660.tistory.com/54)

현재 순열의 상태에서 크기순으로(사전순) 다음에 올 수 있는 순열을 생성해주는 역할을 하는 함수

c++의 경우 라이브러리가 있으나 java의 경우에는 없기 때문에 스스로 만들어서 쓴다..

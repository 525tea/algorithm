
# LIS (최장 증가 부분 수열)

    LIS란 주어진 수열에서 순서를 유지하면서(인덱스 기준) 값이 오름차순으로 증가하는 부분 수열 중 길이 가장 긴 것을 의미한다
    
    LIS를 구하는 기본 아이디어 : 배열의 원소를 앞에서부터 차례로 탐색하며 각 원소를 마지막으로 하는 최장 증가 부분 수열을 계산


    > 즉, 각 원소를 마지막으로 하는 증가 부분 수열 중 최댓값(길이 or 원소 합 등)을 dp[원소 idx]에 저장한다
    
    > 따라서 dp 배열의 각 원소 dp[i]는 해당 인덱스(i)까지 고려했을 때,
    
    > i번째 원소를 끝으로 하는 증가 부분 수열의 최적값(길이 또는 합)을 의미한다

    >>> ⭐️ 이전의 LIS에 현재 원소를 이어붙일지 or 현재 원소로 새로운 LIS를 시작할지 두 선택지 중 더 큰 값을 선택한다

           (boj 1912와 유사. “이전 상태의 최적해를 현재에 이어붙일지, 새로 시작할지”. 비연속 + 값의 오름차순에서 차이가 있음)

**포인트**

- 인덱스는 오름차순
    - 단, 부분 수열이므로 연속할 필요는 없음
- 값은 증가하는 흐름을 유지해야 함 (A[j] < A[i])

**예시**

    A = [10, 20, 10, 30, 20, 50]
    
    → LIS = [10, 20, 30, 50], 길이 = 4

### 풀이 방법

- 점화식 기반 DP
- 이분 탐색 (최적화)


구하는 값에 따라 아래와 같이 구분 가능

| 구분      | 의미 | 점화식 예시 | 문제 예시     |
|---------|---|---|-----------|
| LIS의 길이 | 가장 긴 수열의 길이를 구함 | `d[i] = 1 + max(d[j])` (A[j] < A[i]) |           |
| LIS의 값  | 가장 큰 합을 갖는 증가 수열을 구함 | `d[i] = A[i] + max(d[j])` (A[j] < A[i]) | boj 11055 |



## 풀이 방법

### 1. 점화식

`d[i] = 1 + max(d[j])`  <- 구하는 게 길이의 최댓값인 경우

`d[i] = A[i] + max(d[j])` <- 구하는 게 합의 최댓값인 경우

(단, 0 ≤ j < i 이고 A[j] < A[i])


- d[i] : i번째 원소를 마지막으로 하는 LIS의 길이 또는 원소들의 합
- A[j] < A[i] : 증가 조건을 만족해야 함

### 2. 초기값

d[1] = 1  <- 구하는 게 길이인 경우

또는 

d[1] = a[i] <- 구하는 게 값인 경우


예시

| i   | A[i]         | 가능한 이전 j                        | 	d[i] 계산        | 	d[i] |
|-----|-------|---------------------------------|-----------------|-------|
| 0	  | 10	    | -	                              | 1	              | 1     |
| 1	  | 20           | 	0	                             | d[0]+1=2        | 	2    |
| 2	  | 10	          | -	                              | 1	              | 1     |
| 3	  | 30	          | 0,1,2	                          | max(1,2,1)+1=3	 | 3     |
| 4	  | 20	| 0,2	| max(1,1)+1=2	   | 2     |
|  5	 |50	| 0,1,2,3,4|	max(1,2,1,3,2)+1=4| 	4    | 

결과 → LIS 길이 = 4

### 예제) boj 11053 가장 긴 증가하는 부분 수열

```java
import java.io.*;
import java.util.*;

public class S11053 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        int[] num = new int[N + 1];
        int[] d = new int[N + 1];

        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= N; i++) {
            num[i] = Integer.parseInt(st.nextToken());
            d[i] = 1; // 초기화 - 자신만 포함
        }

        int ans = 0;
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j < i; j++) {
                if (num[j] < num[i]) {
                    d[i] = Math.max(d[i], d[j] + 1);
                }
            }
            ans = Math.max(ans, d[i]);
        }
        System.out.println(ans);
    }
}

/**
 * LIS : 최장 증가 부분 수열
 *
 * 1. dp 테이블
 * d[i] = num[i]를 마지막 원소로 갖는 LIS의 원소 수
 *
 * 2. 점화식
 * 앞쪽의 LIS에 현재 원소를 붙일 수 있을 때 (i < j, num[j] < num[i])
 * d[i] = max(d[i], d[j] + num[i]) -> 1 4 2 30(i) 의 수열에서 1+2 보다 4가 크므로 i에 마지막 근접한 순서가 아닌 max로 친다
 *
 * 3. 초기값
 * d[i] = num[i] 자기 자신만 선택했을 때
 *
 * 시간복잡도: O(N^2)
 * 공간복잡도: O(N)
 */
```

## 2. 이분 탐색(O(N log N))

- DP보다 빠른 방식
- 실제 LIS를 구하지 않고 길이만 구한다
- 풀이 방법
  1.	수열을 앞에서부터 순회하며,
  2.	LIS 배열의 마지막 원소보다 크면 추가(push),
  3.	그렇지 않으면 해당 값 이상의 원소 중 가장 작은 값을 이분 탐색으로 교체한다
- 의미
  - LIS 배열의 길이 = LIS의 길이
  - LIS 배열의 원소는 실제 LIS는 아니지만 길이는 동일하다.

예시

A = [10, 20, 10, 30, 20, 50]

LIS = []

1) 10 → [10]
2) 20 → [10, 20]
3) 10 → [10, 20] → [10, 20] (10은 10에 덮임)
4) 30 → [10, 20, 30]
5) 20 → [10, 20, 30] → [10, 20, 30]
6) 50 → [10, 20, 30, 50]

결과 → 길이 4



## LIS 문제 유형

|유형	|설명	|시간복잡도|
|--|--|--|
|DP 기본형	|점화식으로 모든 이전 상태 비교	|O(N²)|
|이분 탐색형	|LIS 길이만 구함, 효율적	|O(N log N)|
|변형 문제	|LDS(감소 부분 수열), 2D LIS(좌표), 수열 복원 등	|문제에 따라 다름|


### 요약

LIS는 DP의 하위 개념으로, 각 원소를 마지막으로 하는 부분 수열의 최적값(길이·합 등)을 누적 계산하는 구조이다.

기본적으로 DP 점화식으로 풀 수 있고, 더 빠른 풀이를 위해 이분 탐색을 사용해 O(N log N)에 해결할 수 있다.


<br>

### LIS 문제 

| 문제 번호 | 문제명 | 유형 |
|---|---|---|
| 11053 | [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053) | 기본형 LIS (길이형, O(N²)) |
| 11055 | [가장 큰 증가하는 부분 수열](https://www.acmicpc.net/problem/11055) | 값형 LIS (합 최대, DP 변형) |
| 11054 | [가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054) | LIS + LDS 결합형 |
| 2565 | [전깃줄](https://www.acmicpc.net/problem/2565) | 2D LIS (좌표 기반 정렬 후 LIS) |
| 14002 | [가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002) | LIS + 경로 복원형 |
